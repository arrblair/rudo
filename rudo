#!/usr/local/bin/ruby
require 'rubygems'
require 'dm-core'
require 'dm-migrations'
require 'dm-aggregates'

# uncomment the following line to see database output
#DataMapper::Logger.new($stdout, :debug)
# DataMapper is an ORM, we're using sqlite, cause it's easy
DataMapper.setup(:default, 'sqlite://' + File.expand_path('~/todo.db'))

class Task
  include DataMapper::Resource
  property :id,         Serial
  property :title,      String
  property :ordering,      Integer

  def initialize(title)
    self.title = title
    self.ordering = (self.class.max(:ordering) || 0) + 1
  end

  def to_s
    self.ordering.to_s + '. ' + self.title
  end

  before :destroy do |task|
    # when we delete a task we fill in the gap in ordering it left behind
    # in the future we may decide to not actually destroy the task, but to just have it flagged 'done'
    self.class.all(:ordering.gt => task.ordering).each do |task2|
      task2.ordering -= 1
      task2.save
    end
  end

end

class List

  # prints tasks to the screen
  def self.print_tasks
    puts '*' * 40
    Task.all(:order => [ :ordering.asc ]).each_with_index do |task, index|
      break if index >= 10
      puts task.to_s
    end
    puts '*' * 40
  end

  # adds a task to the end of the list
  def self.add(title=nil)
    raise 'you need to enter a title' unless title
    raise 'that task is already in the list' if Task.first(:title => title)
    Task.new(title).save
  end

  # removes a task from the list, the first one unless otherwise specified
  def self.done(identifier=nil)
    # if there aren't any items in the list...
    raise "there's nothing on your list!" if Task.all.empty?
    if identifier
      begin
        # Integer throws an error if 'identifier' contains anything that isn't numerical
        # begin-rescue anticipates this, and the rescue block is executed if an error is raised
        Task.first(:ordering => Integer(identifier)).destroy
      rescue
        # if 'identifier' wasn't a number, let's see if we have a task with that title instead
        task = Task.first(:title => identifier)
        task ? task.destroy : (raise "'done' should be followed by either the number or title of a task")
      end
    else
      Task.first(:ordering => 1).destroy
    end
  end

  # moves items from the beginning to the end of the list, one by default
  def self.walk(number=1)
    # if there aren't any items in the list...
    raise "you're walking in place" if Task.all.empty?
    begin
      # like in 'done' we are checking to see that we actually have a number
      number = Integer(number)
    rescue
      raise 'walk should be followed by an integer'
    end
    # if they input a number greater than or equal to the number of tasks
    raise "I don't like walking in circles" if number.abs >= Task.count
    invert_set = []
    Task.all(:order => [:ordering.asc]).each do |task|
      # decrease the ordering of all the tasks by number
      task.ordering -= number
      invert_set << task if task.ordering <= 0
      task.save
    end

    invert_set.each do |task|
      # move the tasks with an ordering <= 0 to the end of the list
      ordering = [Task.max(:ordering), 0].max
      task.ordering =  ordering + 1
      task.save
    end

    while Task.min(:ordering) > 1 do
      # fill in the ordering gaps at the beginning of the list, in case user inputs a negative number
      task = Task.first(:ordering => Task.max(:ordering))
      task.ordering = Task.min(:ordering) - 1
      task.save
    end
  end

end

DataMapper.auto_upgrade!
DataMapper.finalize

# believe it or not, it all starts here
begin
  if ARGV[0]
    if ARGV[1]
      # send tries to call the method with the name in ARGV[0]
      List.send(ARGV[0], ARGV[1])
    else
      List.send(ARGV[0])
    end
  end
  List.print_tasks
rescue NoMethodError => ex
  # catch the error where List doesn't have the method from ARGV[0]
  puts "X"*40
  puts "no such option, try 'add', 'done', or 'walk'"
  puts "X"*40
rescue Exception => ex
  # catch and print errors raised by the call to List
  puts "X"*40
  puts ex.message
  puts "X"*40
end

